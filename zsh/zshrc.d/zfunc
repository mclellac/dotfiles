# Utility functions
grey="$(tput bold ; tput setaf 0)"
red=$(tput setaf 1)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
yellow=$(tput setaf 11)
blue=$(tput setaf 68)
brown=$(tput setaf 130)
orange=$(tput setaf 172)
reset=$(tput sgr0)

#------------------------------------------------------------------------------#
#                       Command wrapper functions
#------------------------------------------------------------------------------#
digans() { dig "$*" +noall +answer; }
digsoa() { dig "$*" SOA +noall +answer; }
digmx()  { dig "$*" MX +noall +answer; }
digns()  { dig "$*" NS +noall +answer; }
digany() { dig "$*" ANY +noall +answer; }

#gcluster() {
#	local ctx=$1
#	local zone=$2
#	local prj=$3
#
#	if [[ $# -ne 3 ]]; then
#		printf 'gcluster requires a context, region, and project arguments\nie:\n]\t'
#		printf 'gcluster failover us-west1-b myproject\n'
#		return 1
#	fi
#
#	echo "gcloud container clusters get-credentials ${ctx} --zone ${zone} --project ${prj}"
#	gcloud container clusters get-credentials ${ctx} --zone ${zone} --project ${prj}
#}

kubepass() { kubectl config view -o jsonpath='{.users[?(@.name == "$*")].user.password}' }
kubectx () { kubectl config current-context }
kubeip()   { kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="ExternalIP")].address}' }

#pathln() { echo $PATH | tr : '\n'; }

#--------------------------------------------------------------#
# display certs for given host
# usage:
#      > showcert example.com:443
#--------------------------------------------------------------#
showcert() {
    echo openssl s_client -showcerts -connect $*
    echo -n | openssl s_client -showcerts -connect $*
}

ssldump() {
    NIC=$1
    PORT=$2
    sudo tcpdump -ni $NIC "tcp port ${PORT} and (tcp[((tcp[12] & 0xf0) >> 2)] = 0x16)" -vvvv
}

check_compression() {
    curl -s -I -H 'Accept-Encoding: br,gzip,deflate' $1 |grep -i "Content-Encoding"
}


#--------------------------------------------------------------#
# list the top 20 commands used in history.
#--------------------------------------------------------------#
cmdhist() {
    history | awk '{print $2}' | sort | uniq -c | sort -rn | head -20 | sed 's/.\///g' | \
        awk '!max{max=$1;}{r=""; i=s=60 * $1/max; while(i-->0) r=r"█"; printf "\033[1;34m %15s \033[0m %4d \033[1;36m %s \033[0m %s", $2, $1, r, "\n";}'
}

#--------------------------------------------------------------#
# some Sean Connery, because why not?
#--------------------------------------------------------------#
connerize() {
    echo "connery: $*" | sed -e "s/s/sh/g" -e "s/shsh/sh/g" -e "s/shh/sh/g"
}

connerize-say() {
    echo "$*" | sed -e "s/s/sh/g" -e "s/shsh/sh/g" -e "s/shh/sh/g" | say -v "Alex" -i -r 200
}

#--------------------------------------------------------------#
# Akamai cURL
#   Usage:  akcurl https://example.com
#--------------------------------------------------------------#
akcurl() {
    local headers="Pragma: akamai-x-get-request-id,akamai-x-get-cache-key,akamai-x-cache-on,akamai-x-cache-remote-on,akamai-x-get-true-cache-key,akamai-x-check-cacheable,akamai-x-get-extracted-values,akamai-x-feo-trace,x-akamai-logging-mode: verbose"

    echo "curl -sIXGET \"$@\" -H \"${headers[*]}\""
    curl -sIXGET "$@" -H "${headers[*]}"
}

cache-key-curl() {
    local headers="Pragma: akamai-x-get-cache-key,akamai-x-get-true-cache-key,akamai-x-check-cacheable"

    echo "curl -sIXGET \"$@\" -H \"${headers[*]}\""
    curl -sIXGET "$@" -H "${headers[*]}"
}

#--------------------------------------------------------------#
# Akamai cURL
#   Usage:  akcurl https://www.cbc.ca/lite
#--------------------------------------------------------------#
akcurl_old() {
    AKFLAGS=(
        -H "Pragma: akamai-x-get-request-id, akamai-x-get-cache-key, akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-get-true-cache-key, akamai-x-check-cacheable, akamai-x-get-extracted-values, akamai-x-feo-trace"
        -H "x-akamai-logging-mode: verbose"
        -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.57 Safari/537.17"
        -vv
        -s
        -w "%{http_code}\n"
    )
    echo "curl -siL -D - -o /dev/null ${AKFLAGS[*]} \"$*\""
    curl -siL -D - -o /dev/null "${AKFLAGS[@]}" "$*"
}

#--------------------------------------------------------------#
# Akamai HTTPie
# Usage: akhttp https://www.cbc.ca/lite
#--------------------------------------------------------------#
akhttp() {
  local headers='"Pragma: akamai-x-get-request-id,akamai-x-get-cache-key,akamai-x-cache-on,akamai-x-cache-remote-on,akamai-x-get-true-cache-key,akamai-x-check-cacheable,akamai-x-get-extracted-values,akamai-x-feo-trace,x-akamai-logging-mode: verbose"'
  echo "http --headers \"$*\" ${headers[*]}"
  http --headers "$@" "${headers[@]}"
}

aklab() {
    AKFLAGS=(-H "Pragma: akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-check-cacheable, akamai-x-get-cache-key, akamai-x-get-ssl-client-session-id, akamai-x-get-true-cache-key, akamai-x-get-request-id" -H "x-akamai-logging-mode: verbose" -vv -H "User-Agent: AU-KSD")
        curl -I ${AKFLAGS[@]} "$*"
}

# Function to pull changes for Git repositories under a specified directory
# Usage: pull [directory under ~/Projects/src]
# Example: pull bitbucket.org
pull() {
    # Disable xtrace to prevent printing variable assignments
    local xtrace_restore=$(set +o | grep xtrace)
    set +x

    # Base directory where repositories are stored (e.g., ~/Projects/src)
    local base_src_dir="${HOME}/Projects/src"

    # Default directory to search if no argument is provided
    local search_dir="${base_src_dir}"

    # Using tput if available
    local green red cyan yellow reset
    if tput setaf 0 &>/dev/null; then
        green=$(tput setaf 2)
        red=$(tput setaf 1)
        cyan=$(tput setaf 6)
        yellow=$(tput setaf 3)
        reset=$(tput sgr0)
    else
        green='\033[0;32m'
        red='\033[0;31m'
        cyan='\033[0;36m'
        yellow='\033[0;33m'
        reset='\033[0m'
    fi

    # Icons
    local icon_github=""      # GitHub icon
    local icon_bitbucket=""   # Bitbucket/Stash icon
    local icon_gitlab=""      # GitLab icon
    local icon_default="📦"    # Generic package icon
    local icon_success=""
    local icon_uptodate=""
    local icon_error=""

    if [[ -n "$1" ]]; then
        search_dir="${base_src_dir}/$1"

        if [[ ! -d "${search_dir}" ]]; then
            printf "${red}Error: Directory not found: %s${reset}\n" "${search_dir}" >&2
            return 1 # Indicate failure
        fi
    fi

    # Check if the base source directory exists
    if [[ ! -d "${base_src_dir}" ]]; then
        printf "${red}Error: Base source directory not found: %s${reset}\n" "${base_src_dir}" >&2
        return 1
    fi

    # Find directories named .git, pruning the search to avoid looking inside them
    local IFS=$'\n'
    local git_dirs=()
    while IFS= read -r -d '' gitdir; do
        git_dirs+=("$gitdir")
    done < <(find "${search_dir}" -type d -name .git -print0)

    if [[ ${#git_dirs[@]} -eq 0 ]]; then
        printf "${yellow}No Git repositories found under %s${reset}\n" "${search_dir}"
        return 0 
    fi

    printf "${cyan}Found %d repositories under %s. Pulling...${reset}\n" ${#git_dirs[@]} "${search_dir}"

    local original_dir="$PWD" # Store current directory to return later

    # Use flag to track if any pull failed
    local overall_status=0

    for gitdir in "${git_dirs[@]}"; do
        # Get the parent directory of the .git directory, which is the repo root
        local repo_path
        repo_path=$(dirname "$gitdir")

        # Ensure repo_path is under base_src_dir
        if [[ "${repo_path}/" != "${base_src_dir}/"* && "${repo_path}" != "${base_src_dir}" ]]; then
             printf "${yellow}Warning: Skipping potentially unsafe path: %s${reset}\n" "${repo_path}" >&2
             overall_status=1
             continue
        fi

        # Get the path relative to the base source directory for display
        local relative_path="${repo_path#${base_src_dir}/}"

        # Navigate into the repository directory
        # Check if cd was successful
        if ! cd "${repo_path}"; then
            printf "${red}Error: Could not change directory to %s${reset}\n" "${repo_path}" >&2
            overall_status=1 # Mark as failure
            continue # Skip this repository
        fi

        # Get the current branch name
        local branch
        branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ -z "$branch" ]]; then
            branch="(detached HEAD)"
        fi

        # Get the remote origin URL
        local origin_url
        origin_url=$(git config --get remote.origin.url 2>/dev/null)

        # Determine icon based on URL
        local icon="${icon_default}" # Default icon
        if [[ -n "${origin_url}" ]]; then
            if [[ "${origin_url}" =~ "github.com" ]]; then
                icon="${icon_github}"
            elif [[ "${origin_url}" =~ "bitbucket.org" || "${origin_url}" =~ "stash.nm.cbc.ca" ]]; then
                 icon="${icon_bitbucket}"
            elif [[ "${origin_url}" =~ "gitlab.nm.cbc.ca" ]]; then
                 icon="${icon_gitlab}"
            fi
        fi

        # Print repository path and branch before pulling
        printf "${cyan}%s %s %s (%s)%s ... " "${icon}" "${green}" "${relative_path}" "${branch}" "${reset}"

        # Perform the pull operation
        # Use --ff-only to avoid creating merge commits on simple pulls
        local pull_output
        local pull_status=0
        pull_output=$(git pull --ff-only 2>&1)
        pull_status=$?

        # Handle the pull result
        local status_icon=""
        local status_message=""
        local status_color=""

        if [[ $pull_status -eq 0 ]]; then
            if [[ "${pull_output}" =~ "Already up to date" ]]; then
                status_icon="${icon_uptodate}"
                status_message="Already up to date."
                status_color="${green}"
            else
                status_icon="${icon_success}"
                status_message="Pulled successfully."
                status_color="${green}"
            fi
            printf "\r${cyan}%s %s %s (%s)%s ${status_color}%s %s${reset}\n" \
                   "${icon}" "${green}" "${relative_path}" "${branch}" "${reset}" \
                   "${status_icon}" "${status_message}"
             if [[ "${pull_output}" != *"Already up to date"* ]]; then
                 echo "${pull_output}" | sed 's/^/  /'
             fi

        else
            # Pull failed
            overall_status=1 # Mark status as failed
            status_icon="${icon_error}"
            status_message="Pull failed (Status: $pull_status)."
            status_color="${red}"

            printf "\r${cyan}%s %s %s (%s)%s ${status_color}%s %s${reset}\n" \
                   "${icon}" "${green}" "${relative_path}" "${branch}" "${reset}" \
                   "${status_icon}" "${status_message}"

            echo "${pull_output}" | sed 's/^/  /' >&2 # Indent and send to stderr
        fi

        # Change back to the search directory for the next iteration
        if ! cd "${search_dir}"; then
            printf "${red}Fatal Error: Could not return to search directory %s${reset}\n" "${search_dir}" >&2
            return 1 # Exit the function immediately on fatal error
        fi

    done

    # Change back to the directory where the function was called
    cd "${original_dir}" || {
         printf "${red}Fatal Error: Could not return to original directory %s${reset}\n" "${original_dir}" >&2
         return 1 # Exit the function immediately on fatal error
    }

    # Return overall status (0 if all succeeded, 1 if any failed or skipped)
    return "${overall_status}"
}

#--------------------------------------------------------------#
# A simple calculator for a simple person.
#--------------------------------------------------------------#
calc() {
    # you will need to escape multiplication (ie: "calc 2 \* 20").
    local result=""
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
                            # └─ default (when `--mathlib` is used) is 20
        if [[ "$result" == *.* ]]; then
            printf "$result" | sed -e 's/^\./0./' \
                -e 's/^-\./-0./' \
                -e 's/0*$//;s/\.$//'
        else
            printf "$result"
                fi
                printf "\n"
}
